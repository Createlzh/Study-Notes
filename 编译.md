# 编译

[TOC]

## 1. 编译与链接

##### 可执行程序

* 双击后就可以直接运行的程序，这样的程序被称为可执行程序（Executable Program）

  在 Windows 下，可执行程序的后缀有`.exe`和`.com`（其中`.exe`比较常见）。在类 UNIX 系统（Linux、Mac OS 等）下，可执行程序没有特定的后缀，系统根据文件的头部信息来判断是否是可执行程序。

* 可执行程序的内部是一系列二进制形式的计算机指令和数据的集合，CPU 可以直接识别，但是对于程序员，它们非常晦涩。

  * 屏幕上C语言输出：
  
    ```C
    puts("VIP会员");
    ```

  * 使用指令输出：
  
    ![二进制](C:\Users\zhliao\Documents\编译.assets\11103541N-0.jpg)
  
  在计算机发展的初期，程序员就是使用这样的二进制指令来编写程序的，但频繁查询指令手册，效率低下难以排查错误。这就倒逼程序员开发出了编程语言，提高自己的生产力，例如汇编、C语言、Java、Python、Go语言等，都是在逐步提高开发效率



##### 编译(Compile)

* 编译器

  C语言代码由固定的词汇按照固定的格式组织起来，简单直观，程序员容易识别和理解，但是对于CPU，C语言代码就是天书，根本不认识，CPU只认识几百个二进制形式的指令。这就需要一个工具，将C语言代码转换成CPU能够识别的二进制指令，也就是将代码加工成 .exe 程序的格式；这个工具是一个特殊的软件，叫做**编译器（Compiler）。**

* 编译

  编译器能够识别代码中的词汇、句子以及各种特定的格式，并将他们转换成计算机能够识别的二进制形式，这个过程称为**编译（Compile）**。

  它是一个复杂的过程，大致包括词法分析、语法分析、语义分析、性能优化、生成可执行文件五个步骤，期间涉及到复杂的算法和硬件架构。

  你的代码语法正确与否，编译器说了才算，我们学习C语言，从某种意义上说就是学习如何使用编译器。

  编译器可以 100% 保证你的代码从语法上讲是正确的，因为哪怕有一点小小的错误，编译也不能通过，编译器会告诉你哪里错了，便于你的更改。



##### 链接(Link)

* 目标文件

  C语言代码经过编译以后，并没有生成最终的可执行文件（.exe 文件），而是生成了一种叫做**目标文件（Object File）**的中间文件（或者说临时文件）。

  目标文件也是二进制形式的，它和可执行文件的格式是一样的。对于 Visual C++，目标文件的后缀是`.obj`；对于 GCC，目标文件的后缀是`.o`。

  目标文件经过链接（Link）以后才能变成可执行文件。既然目标文件和可执行文件的格式是一样的，为什么还要再链接一次呢，直接作为可执行文件不行吗？

  不行的！因为编译只是将我们自己写的代码变成了二进制形式，它还需要和系统组件（比如标准库、动态链接库等）结合起来，这些组件都是程序运行所必须的。

* 链接

  **链接（Link）**其实就是一个“打包”的过程，它将所有二进制形式的目标文件和系统组件组合成一个可执行文件。完成链接的过程也需要一个特殊的软件，叫做**链接器（Linker）**。

  随着我们学习的深入，我们编写的代码越来越多，最终需要将它们分散到多个源文件中，**编译器每次只能编译一个源文件，生成一个目标文件**，这个时候，链接器除了将目标文件和系统组件组合起来，还需要**将编译器生成的多个目标文件组合起来**。

  再次强调，**编译是针对一个源文件的，有多少个源文件就需要编译多少次，就会生成多少个目标文件。**
  
  > 例如，main.c，test.c，这两个源文件需要编译两次，分别编译成main.o和test.o，再通过链接将main.o和test.o生成可执行文件main.out



##### 总结

不管我们编写的代码有多么简单，都必须经过**「编译 --> 链接」**的过程才能生成可执行文件：

- 编译就是将我们编写的源代码“翻译”成计算机可以识别的二进制格式，它们以目标文件的形式存在；
- 链接就是一个“打包”的过程，它将所有的目标文件以及系统组件组合成一个可执行文件。



## 2. GCC、gcc与g++

##### 基本概念

* **GCC**：GNU Compiler Collection(GUN 编译器集合)，它可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada等语言

  > 在早期，GCC为**GNU C Compiler**的简写，即GNU计划中的C语言编译器。 但经过多年的扩展和迭代，GCC逐渐支持C、C++、Objective-C、Fortran、Java、Ada和Go等越来越多语言的编译。 因此，其GCC被重新定义为**GNU Compiler Collection**，即 GNU编译器套件。

* **gcc**：GCC中的GUN C Compiler（C 编译器）

* **g++**：GCC中的GUN C++ Compiler（C++编译器）



##### gcc编译步骤

* 本质而言，gcc和g++并不是编译器，也不是编译器的集合，它们只是一种驱动器，根据参数中要编译的文件的类型，调用对应的GUN编译器而已。

* 比如，用gcc编译一个c文件的话，包含**预处理**、**编译**、**汇编**、**链接**等四个步骤：

  ```C
  Step1：Call a preprocessor, like cpp.
  Step2：Call an actual compiler, like cc or cc1.
  Step3：Call an assembler, like as.
  Step4：Call a linker, like ld
      
  //以输入C语言程序源码文件b.c为例，直接调用命令gcc b.c，将会完整执行以下流程，并生成对应的可执行的二进制文件a.out:    
        -E          -S          -c          
  b.c ------> b.i ------> b.s ------> b.o ------> a.out
        gcc         gcc         as          ld
  //汇编由工具as完成，链接则由工具ld完成
  ```

  > 对`gcc`使用以下指令，将会使其编译流程**停止**在对应位置：
  >
  > - `-E`，（pr**E**processing），执行到**预处理**步骤之后，即处理C/C++源码中`#`开头的指令，包括**宏展开**以及`#include`**头文件引入**等等。 该指令默认不输出文件，可以使用`-o`指令输出约定后缀为`*.i`的文件。
  > - `-S`，（a**S**sembly），执行到**编译**步骤之后，生成汇编文件，但不生成二进制机器码。 该指令默认的输出文件后缀为`*.s`。
  > - `-c`，（**c**ompilation），执行到**汇编**步骤之后，调用工具`as`，从汇编码生成二进制机器码，但不进行链接。 该指令默认的输出文件后缀为`*.o`（**o**bject）。
  > - 不带以上参数调用`gcc`将会完整执行以上流程，即执行到到**链接**（linking）步骤之后。 链接步骤实际上调用链接工具`ld`来执行，会将源码生成的二进制文件，库文件，以及程序的启动部分进行组合，从而形成一个完整的二进制可执行文件。
  > - 特别的，使用指令`-o`，（**o**utput），可以指定输出文件的名称。 例如`gcc b.c -o b.bin`，将生成可执行文件`b.bin`，而不是默认的`a.out`。

* 由于编译器是可以更换的，所以gcc不仅仅可以编译C文件

* 更准确的说法是：**gcc调用了C compiler，而g++调用了C++ compiler**



##### gcc与g++的主要区别

1. 对于 .c和.cpp文件，gcc分别当做c和cpp文件编译（c和cpp的语法强度是不一样的）

2. 对于 .c和.cpp文件，g++则统一当做cpp文件编译

3. 使用g++编译文件时，g++会自动链接标准库STL，而gcc不会自动链接STL

4. gcc在编译C文件时，可使用的预定义宏是比较少的

5. gcc在编译cpp文件时/g++在编译c文件和cpp文件时（这时候gcc和g++调用的都是cpp文件的编译器），会加入一些额外的宏，这些宏如下：

   ```C
   #define __GXX_WEAK__ 1
   #define __cplusplus 1
   #define __DEPRECATED 1
   #define __GNUG__ 4
   #define __EXCEPTIONS 1
   #define __private_extern__ extern
   ```



##### 误区

* 误区一：gcc只能编译C代码，g++只能编译C++代码。
  两者都可以，但请注意：

  （1）后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是C++程序，注意，虽然C++是C的超集，但是两者对语法的要求是有区别的。C++的语法规则更加严谨一些。
  （2）编译阶段，g++会调用gcc，对于C++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。

* 误区二：gcc不会定义__cplusplus宏，而g++会

  实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释，如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义。

* 误区三：编译只能用gcc，链接只能用g++

  严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C++程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。

 

## 3. Make与Cmake

##### make

写程序大体步骤为：

1.用编辑器编写源代码，如.c文件。

2.用编译器编译代码生成目标文件，如.o。

3.用链接器连接目标代码生成可执行文件，如.exe。

但如果源文件太多，一个一个编译时就会特别麻烦，于是人们想到，为什么不设计一种类似批处理的程序，来批处理编译源文件呢，于是就有了make工具，它是一个自动化编译工具，你可以使用一条命令实现完全编译。但是你需要编写一个规则文件，make依据它来批处理编译，这个文件就是makefile，所以编写makefile文件也是一个程序员所必备的技能。



##### cmake

对于一个大工程，编写makefile实在是件复杂的事，于是人们又想，为什么不设计一个工具，读入所有源文件之后，自动生成makefile呢，于是就出现了cmake工具，它能够输出各种各样的makefile或者project文件,从而帮助程序员减轻负担。但是随之而来也就是编写cmakelist文件，它是cmake所依据的规则。所以在编程的世界里没有捷径可走，还是要脚踏实地的。

![img](C:\Users\zhliao\Documents\编译.assets\70.png)



##### 编译工具链

C/C++项目的构建编译常用工具链：GCC，Make，以及CMake。

 其中，GCC是C/C++语言的编译工具，Make是增量式（编译）批处理工具，CMake是Make脚本生成工具。 在现代C/C++项目的构建中，它们的关系如下。

```C
              cmake           make       gcc
CMakelist.txt -----> Makefile ----> Cmds ---> Binary
```

开发者需要编写`CMakelist.txt`文件，来配置项目相关的CMake参数。 通过运行`cmake`命令，自动生成对应平台的Make工具自动构建脚本`Makefile`文件。

使用Make工具来编译C/C++项目时，一般会使用Shell命令来调用`gcc`，**自动化**且**增量式**地实现C/C++源代码的编译链接等一系列工作。



## 4. 交叉编译

##### 本地编译

本地编译可以理解为，在当前编译平台下，编译出来的程序只能放到当前平台下运行。平时我们常见的软件开发，都是属于本地编译：

比如，我们在 x86 平台上，编写程序并编译成可执行程序。这种方式下，我们使用 x86 平台上的工具，开发针对 x86 平台本身的可执行程序，这个编译过程称为本地编译。


##### 交叉编译

交叉编译可以理解为，在当前编译平台下，编译出来的程序能运行在体系结构不同的另一种目标平台上，但是编译平台本身却不能运行该程序：

比如，我们在 x86 平台上，编写程序并编译成能运行在 ARM 平台的程序，编译得到的程序在 x86 平台上是不能运行的，必须放到 ARM 平台上才能运行。


##### Why交叉编译

需要交叉编译的原因：

* Speed： 目标平台的运行速度往往比主机慢得多，许多专用的嵌入式硬件被设计为低成本和低功耗，没有太高的性能
* Capability： 整个编译过程是非常消耗资源的，嵌入式系统往往没有足够的内存或磁盘空间
* Availability： 即使目标平台资源很充足，可以本地编译，但是第一个在目标平台上运行的本地编译器总需要通过交叉编译获得
* Flexibility： 一个完整的Linux编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标板上

交叉编译的困难点：

* 不同的体系架构拥有不同的机器特性

  > **Word size：** 是64位还是32位系统
  >
  > **Endianness：** 是大端还是小端系统
  >
  > **Alignment：** 是否必修按照4字节对齐方式进行访问
  >
  > **Default signedness：** 默认数据类型是有符号还是无符号
  >
  > **NOMMU：** 是否支持MMU

* 交叉编译时的主机环境与目标环境不同

  > **Configuration issues：**
  >
  > **HOSTCC vs TARGETCC：**
  >
  > **Toolchain Leaks：**
  >
  > **Libraries：**
  >
  > **Testing：**



##### 交叉编译链

编译过程是按照不同的子功能，依照先后顺序组成的一个复杂的流程：

![编译流程](C:\Users\zhliao\Documents\编译.assets\20161024170548772.jpeg)

编译过程包括了预处理、编译、汇编、链接等功能。既然有不同的子功能，那每个子功能都是一个单独的工具来实现，它们合在一起形成了一个完整的工具集。

同时编译过程又是一个有先后顺序的流程，它必然牵涉到工具的使用顺序，每个工具按照先后关系串联在一起，这就形成了一个链式结构。

因此，**交叉编译链**就是为了编译跨平台体系结构的程序代码而形成的由多个子工具构成的一套完整的工具集。同时，它隐藏了预处理、编译、汇编、链接等细节，当我们指定了源文件(.c)时，它会自动按照编译流程调用不同的子工具，自动生成最终的二进制程序映像(.bin)。




## 参考

1. [C语言编译和链接详解（通俗易懂，深入本质）](http://c.biancheng.net/view/1736.html)
2. [GCC与gcc，g++区别](https://blog.csdn.net/weixin_39303983/article/details/118671256)
3. [GCC/Make/CMake 之 GCC](https://zhuanlan.zhihu.com/p/342151242)
4. [CMake与Make最简单直接的区别](https://blog.csdn.net/weixin_42491857/article/details/80741060)
5. [交叉编译详解 一 概念篇](https://blog.csdn.net/pengfei240/article/details/52912833)
